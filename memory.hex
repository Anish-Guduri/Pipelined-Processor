
0x4c400004  // MOV r1, 4  ; Move the immediate value 4 into register r1
0x4c0004d2  // mov r0, 1234 
0x4c8003e8  // mov r2, 1000
0x4cc00032  // mov r3, 50
0x4d000101  // mov r4, 257
0x4d405014  // mov r5, 20500
0x2c040004  // CMP r1, 4  ; Compare register r1 with the immediate value 4
0x0a4d0000  // sub r9, r3, r4
0x80000002  // BEQ .loop  ; Branch to label .loop if r1 equals 4 (branch offset = 2)
0x019e4000  // ADD r6, r7, r9  ; Add the values in registers r7 and r9, store result in r6
0x019e0000  // ADD r6, r7, r8  ; Add the values in registers r7 and r8, store result in r6


0x4c400004
0x2c040004
0x80000002
0x019e4000
0x019e0000



4c0004d2
4c400004
4c8003e8
4cc00032
4d000101
4d405014
7c0404d4
2c040004
01804000
11c48000
1a08c000
0a4d0000
770404d4

0x4c0004d2  // mov r0, 1234  0
0x4c400004  // mov r1, 4        
0x01804000  // add r6, r0, r1
0x4c8003e8  // mov r2, 1000
0x4cc00032  // mov r3, 50
0x4d000101  // mov r4, 257
0x4d405014  // mov r5, 20500
0x7c0404d4  // st r0, 0x4d4[r1]
0x2c040004  CMP r1, 4  ;
0x0a4d0000  // sub r9, r3, r4
0x80000002  // BEQ .loop  ;
0x11c48000  // mul r7, r1, r2
0x1a08c000  // div r8, r2, r3
0x770404d4   // ld r12, 0x4d4[r1]



PS D:\Downloads\interpreter> .\a.exe .\loop.asm
mov r12,  1000: 0x4f0003e8
st r0, 0x4d4[r1]: 0x7c0404d4
add r6, r3, r4: 0x018d0000
sub r7, r8, r9: 0x09e24000
sub r5, r11, 434: 0x0d6c01b2
mul r10, r3, r12: 0x128f0000


4c0004d2  // mov r0, 1234
4c400000  // mov r1, 0
7c0404d4  // st r0, 0x4d4[r1]
4c800c35  // mov r2, 0xc35
7c88f55b  // st r2, 0xf55b[r2]
778404d4  // ld r14, 0x4d4[r1]
77c8f55b  // ld r15, 0xf55b[r2]




mov r0, 5: 0x4c000005
mov r1, 1: 0x4c400001
mov r2, 1: 0x4c800001
cmp r2, r0: 0x28080000
bgt .break: 0x88000004
mul r1, r1, r2: 0x10448000
add r2, r2, 1: 0x04880001
b .loop  : 0x97fffffc




4c0004d2
4c400000
7c0404d4
4c800c35
7c88f55b
778404d4
77c8f55b